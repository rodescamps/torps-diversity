// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_spec.proto

#ifndef PROTOBUF_message_5fspec_2eproto__INCLUDED
#define PROTOBUF_message_5fspec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace torps {
namespace ext {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_5fspec_2eproto();
void protobuf_AssignDesc_message_5fspec_2eproto();
void protobuf_ShutdownFile_message_5fspec_2eproto();

class StatusMessage;
class CongestionProfile;
class NodeSpecification;
class LatencyInfo;
class CoordInit;
class Coordinate;
class CoordUpdate;
class ControlMessage;

enum StatusMessage_Status {
  StatusMessage_Status_OK = 1,
  StatusMessage_Status_ERR = 2,
  StatusMessage_Status_DATA_NEXT = 3
};
bool StatusMessage_Status_IsValid(int value);
const StatusMessage_Status StatusMessage_Status_Status_MIN = StatusMessage_Status_OK;
const StatusMessage_Status StatusMessage_Status_Status_MAX = StatusMessage_Status_DATA_NEXT;
const int StatusMessage_Status_Status_ARRAYSIZE = StatusMessage_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusMessage_Status_descriptor();
inline const ::std::string& StatusMessage_Status_Name(StatusMessage_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusMessage_Status_descriptor(), value);
}
inline bool StatusMessage_Status_Parse(
    const ::std::string& name, StatusMessage_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusMessage_Status>(
    StatusMessage_Status_descriptor(), name, value);
}
enum Type {
  INIT = 1,
  GET = 2,
  COORDS = 3
};
bool Type_IsValid(int value);
const Type Type_MIN = INIT;
const Type Type_MAX = COORDS;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class StatusMessage : public ::google::protobuf::Message {
 public:
  StatusMessage();
  virtual ~StatusMessage();

  StatusMessage(const StatusMessage& from);

  inline StatusMessage& operator=(const StatusMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusMessage& default_instance();

  void Swap(StatusMessage* other);

  // implements Message ----------------------------------------------

  StatusMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusMessage& from);
  void MergeFrom(const StatusMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StatusMessage_Status Status;
  static const Status OK = StatusMessage_Status_OK;
  static const Status ERR = StatusMessage_Status_ERR;
  static const Status DATA_NEXT = StatusMessage_Status_DATA_NEXT;
  static inline bool Status_IsValid(int value) {
    return StatusMessage_Status_IsValid(value);
  }
  static const Status Status_MIN =
    StatusMessage_Status_Status_MIN;
  static const Status Status_MAX =
    StatusMessage_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    StatusMessage_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return StatusMessage_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return StatusMessage_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return StatusMessage_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .torps.ext.StatusMessage.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::torps::ext::StatusMessage_Status status() const;
  inline void set_status(::torps::ext::StatusMessage_Status value);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:torps.ext.StatusMessage)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static StatusMessage* default_instance_;
};
// -------------------------------------------------------------------

class CongestionProfile : public ::google::protobuf::Message {
 public:
  CongestionProfile();
  virtual ~CongestionProfile();

  CongestionProfile(const CongestionProfile& from);

  inline CongestionProfile& operator=(const CongestionProfile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CongestionProfile& default_instance();

  void Swap(CongestionProfile* other);

  // implements Message ----------------------------------------------

  CongestionProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CongestionProfile& from);
  void MergeFrom(const CongestionProfile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline ::google::protobuf::uint32 identifier() const;
  inline void set_identifier(::google::protobuf::uint32 value);

  // required uint32 binsize = 2;
  inline bool has_binsize() const;
  inline void clear_binsize();
  static const int kBinsizeFieldNumber = 2;
  inline ::google::protobuf::uint32 binsize() const;
  inline void set_binsize(::google::protobuf::uint32 value);

  // repeated double binprobs = 3;
  inline int binprobs_size() const;
  inline void clear_binprobs();
  static const int kBinprobsFieldNumber = 3;
  inline double binprobs(int index) const;
  inline void set_binprobs(int index, double value);
  inline void add_binprobs(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      binprobs() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_binprobs();

  // @@protoc_insertion_point(class_scope:torps.ext.CongestionProfile)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_binsize();
  inline void clear_has_binsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 identifier_;
  ::google::protobuf::uint32 binsize_;
  ::google::protobuf::RepeatedField< double > binprobs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static CongestionProfile* default_instance_;
};
// -------------------------------------------------------------------

class NodeSpecification : public ::google::protobuf::Message {
 public:
  NodeSpecification();
  virtual ~NodeSpecification();

  NodeSpecification(const NodeSpecification& from);

  inline NodeSpecification& operator=(const NodeSpecification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeSpecification& default_instance();

  void Swap(NodeSpecification* other);

  // implements Message ----------------------------------------------

  NodeSpecification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeSpecification& from);
  void MergeFrom(const NodeSpecification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 congestion_profile = 2;
  inline bool has_congestion_profile() const;
  inline void clear_congestion_profile();
  static const int kCongestionProfileFieldNumber = 2;
  inline ::google::protobuf::uint32 congestion_profile() const;
  inline void set_congestion_profile(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:torps.ext.NodeSpecification)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_congestion_profile();
  inline void clear_has_congestion_profile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 congestion_profile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static NodeSpecification* default_instance_;
};
// -------------------------------------------------------------------

class LatencyInfo : public ::google::protobuf::Message {
 public:
  LatencyInfo();
  virtual ~LatencyInfo();

  LatencyInfo(const LatencyInfo& from);

  inline LatencyInfo& operator=(const LatencyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatencyInfo& default_instance();

  void Swap(LatencyInfo* other);

  // implements Message ----------------------------------------------

  LatencyInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatencyInfo& from);
  void MergeFrom(const LatencyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 n1_idx = 1;
  inline bool has_n1_idx() const;
  inline void clear_n1_idx();
  static const int kN1IdxFieldNumber = 1;
  inline ::google::protobuf::uint32 n1_idx() const;
  inline void set_n1_idx(::google::protobuf::uint32 value);

  // required uint32 n2_idx = 2;
  inline bool has_n2_idx() const;
  inline void clear_n2_idx();
  static const int kN2IdxFieldNumber = 2;
  inline ::google::protobuf::uint32 n2_idx() const;
  inline void set_n2_idx(::google::protobuf::uint32 value);

  // required double latency = 3;
  inline bool has_latency() const;
  inline void clear_latency();
  static const int kLatencyFieldNumber = 3;
  inline double latency() const;
  inline void set_latency(double value);

  // @@protoc_insertion_point(class_scope:torps.ext.LatencyInfo)
 private:
  inline void set_has_n1_idx();
  inline void clear_has_n1_idx();
  inline void set_has_n2_idx();
  inline void clear_has_n2_idx();
  inline void set_has_latency();
  inline void clear_has_latency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 n1_idx_;
  ::google::protobuf::uint32 n2_idx_;
  double latency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static LatencyInfo* default_instance_;
};
// -------------------------------------------------------------------

class CoordInit : public ::google::protobuf::Message {
 public:
  CoordInit();
  virtual ~CoordInit();

  CoordInit(const CoordInit& from);

  inline CoordInit& operator=(const CoordInit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordInit& default_instance();

  void Swap(CoordInit* other);

  // implements Message ----------------------------------------------

  CoordInit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoordInit& from);
  void MergeFrom(const CoordInit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_networks = 1 [default = 1];
  inline bool has_num_networks() const;
  inline void clear_num_networks();
  static const int kNumNetworksFieldNumber = 1;
  inline ::google::protobuf::uint32 num_networks() const;
  inline void set_num_networks(::google::protobuf::uint32 value);

  // required uint32 update_interval_seconds = 2;
  inline bool has_update_interval_seconds() const;
  inline void clear_update_interval_seconds();
  static const int kUpdateIntervalSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 update_interval_seconds() const;
  inline void set_update_interval_seconds(::google::protobuf::uint32 value);

  // optional uint32 ping_interval_seconds = 3 [default = 3];
  inline bool has_ping_interval_seconds() const;
  inline void clear_ping_interval_seconds();
  static const int kPingIntervalSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 ping_interval_seconds() const;
  inline void set_ping_interval_seconds(::google::protobuf::uint32 value);

  // repeated .torps.ext.NodeSpecification node_data = 4;
  inline int node_data_size() const;
  inline void clear_node_data();
  static const int kNodeDataFieldNumber = 4;
  inline const ::torps::ext::NodeSpecification& node_data(int index) const;
  inline ::torps::ext::NodeSpecification* mutable_node_data(int index);
  inline ::torps::ext::NodeSpecification* add_node_data();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >&
      node_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >*
      mutable_node_data();

  // repeated .torps.ext.LatencyInfo latency_map = 5;
  inline int latency_map_size() const;
  inline void clear_latency_map();
  static const int kLatencyMapFieldNumber = 5;
  inline const ::torps::ext::LatencyInfo& latency_map(int index) const;
  inline ::torps::ext::LatencyInfo* mutable_latency_map(int index);
  inline ::torps::ext::LatencyInfo* add_latency_map();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >&
      latency_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >*
      mutable_latency_map();

  // repeated .torps.ext.CongestionProfile congestion_profiles = 6;
  inline int congestion_profiles_size() const;
  inline void clear_congestion_profiles();
  static const int kCongestionProfilesFieldNumber = 6;
  inline const ::torps::ext::CongestionProfile& congestion_profiles(int index) const;
  inline ::torps::ext::CongestionProfile* mutable_congestion_profiles(int index);
  inline ::torps::ext::CongestionProfile* add_congestion_profiles();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::CongestionProfile >&
      congestion_profiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::CongestionProfile >*
      mutable_congestion_profiles();

  // @@protoc_insertion_point(class_scope:torps.ext.CoordInit)
 private:
  inline void set_has_num_networks();
  inline void clear_has_num_networks();
  inline void set_has_update_interval_seconds();
  inline void clear_has_update_interval_seconds();
  inline void set_has_ping_interval_seconds();
  inline void clear_has_ping_interval_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 num_networks_;
  ::google::protobuf::uint32 update_interval_seconds_;
  ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification > node_data_;
  ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo > latency_map_;
  ::google::protobuf::RepeatedPtrField< ::torps::ext::CongestionProfile > congestion_profiles_;
  ::google::protobuf::uint32 ping_interval_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static CoordInit* default_instance_;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  void Swap(Coordinate* other);

  // implements Message ----------------------------------------------

  Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required int32 dim = 2;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline ::google::protobuf::int32 dim() const;
  inline void set_dim(::google::protobuf::int32 value);

  // required double error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline double error() const;
  inline void set_error(double value);

  // repeated double vectors = 4;
  inline int vectors_size() const;
  inline void clear_vectors();
  static const int kVectorsFieldNumber = 4;
  inline double vectors(int index) const;
  inline void set_vectors(int index, double value);
  inline void add_vectors(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      vectors() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_vectors();

  // @@protoc_insertion_point(class_scope:torps.ext.Coordinate)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_dim();
  inline void clear_has_dim();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* node_id_;
  double error_;
  ::google::protobuf::RepeatedField< double > vectors_;
  ::google::protobuf::int32 dim_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class CoordUpdate : public ::google::protobuf::Message {
 public:
  CoordUpdate();
  virtual ~CoordUpdate();

  CoordUpdate(const CoordUpdate& from);

  inline CoordUpdate& operator=(const CoordUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordUpdate& default_instance();

  void Swap(CoordUpdate* other);

  // implements Message ----------------------------------------------

  CoordUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoordUpdate& from);
  void MergeFrom(const CoordUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 network_id = 1;
  inline bool has_network_id() const;
  inline void clear_network_id();
  static const int kNetworkIdFieldNumber = 1;
  inline ::google::protobuf::uint32 network_id() const;
  inline void set_network_id(::google::protobuf::uint32 value);

  // repeated .torps.ext.Coordinate coords = 2;
  inline int coords_size() const;
  inline void clear_coords();
  static const int kCoordsFieldNumber = 2;
  inline const ::torps::ext::Coordinate& coords(int index) const;
  inline ::torps::ext::Coordinate* mutable_coords(int index);
  inline ::torps::ext::Coordinate* add_coords();
  inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >&
      coords() const;
  inline ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >*
      mutable_coords();

  // @@protoc_insertion_point(class_scope:torps.ext.CoordUpdate)
 private:
  inline void set_has_network_id();
  inline void clear_has_network_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate > coords_;
  ::google::protobuf::uint32 network_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static CoordUpdate* default_instance_;
};
// -------------------------------------------------------------------

class ControlMessage : public ::google::protobuf::Message {
 public:
  ControlMessage();
  virtual ~ControlMessage();

  ControlMessage(const ControlMessage& from);

  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlMessage& default_instance();

  void Swap(ControlMessage* other);

  // implements Message ----------------------------------------------

  ControlMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlMessage& from);
  void MergeFrom(const ControlMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .torps.ext.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::torps::ext::Type type() const;
  inline void set_type(::torps::ext::Type value);

  // optional .torps.ext.CoordInit init_data = 2;
  inline bool has_init_data() const;
  inline void clear_init_data();
  static const int kInitDataFieldNumber = 2;
  inline const ::torps::ext::CoordInit& init_data() const;
  inline ::torps::ext::CoordInit* mutable_init_data();
  inline ::torps::ext::CoordInit* release_init_data();
  inline void set_allocated_init_data(::torps::ext::CoordInit* init_data);

  // optional .torps.ext.CoordUpdate update_data = 3;
  inline bool has_update_data() const;
  inline void clear_update_data();
  static const int kUpdateDataFieldNumber = 3;
  inline const ::torps::ext::CoordUpdate& update_data() const;
  inline ::torps::ext::CoordUpdate* mutable_update_data();
  inline ::torps::ext::CoordUpdate* release_update_data();
  inline void set_allocated_update_data(::torps::ext::CoordUpdate* update_data);

  // optional uint32 get_network_id = 4;
  inline bool has_get_network_id() const;
  inline void clear_get_network_id();
  static const int kGetNetworkIdFieldNumber = 4;
  inline ::google::protobuf::uint32 get_network_id() const;
  inline void set_get_network_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:torps.ext.ControlMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_init_data();
  inline void clear_has_init_data();
  inline void set_has_update_data();
  inline void clear_has_update_data();
  inline void set_has_get_network_id();
  inline void clear_has_get_network_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::torps::ext::CoordInit* init_data_;
  int type_;
  ::google::protobuf::uint32 get_network_id_;
  ::torps::ext::CoordUpdate* update_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_message_5fspec_2eproto();
  friend void protobuf_AssignDesc_message_5fspec_2eproto();
  friend void protobuf_ShutdownFile_message_5fspec_2eproto();

  void InitAsDefaultInstance();
  static ControlMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// StatusMessage

// required .torps.ext.StatusMessage.Status status = 1;
inline bool StatusMessage::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusMessage::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusMessage::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::torps::ext::StatusMessage_Status StatusMessage::status() const {
  return static_cast< ::torps::ext::StatusMessage_Status >(status_);
}
inline void StatusMessage::set_status(::torps::ext::StatusMessage_Status value) {
  assert(::torps::ext::StatusMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string msg = 2;
inline bool StatusMessage::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusMessage::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusMessage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusMessage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& StatusMessage::msg() const {
  return *msg_;
}
inline void StatusMessage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void StatusMessage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void StatusMessage::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusMessage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* StatusMessage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusMessage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CongestionProfile

// required uint32 identifier = 1;
inline bool CongestionProfile::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CongestionProfile::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CongestionProfile::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CongestionProfile::clear_identifier() {
  identifier_ = 0u;
  clear_has_identifier();
}
inline ::google::protobuf::uint32 CongestionProfile::identifier() const {
  return identifier_;
}
inline void CongestionProfile::set_identifier(::google::protobuf::uint32 value) {
  set_has_identifier();
  identifier_ = value;
}

// required uint32 binsize = 2;
inline bool CongestionProfile::has_binsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CongestionProfile::set_has_binsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CongestionProfile::clear_has_binsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CongestionProfile::clear_binsize() {
  binsize_ = 0u;
  clear_has_binsize();
}
inline ::google::protobuf::uint32 CongestionProfile::binsize() const {
  return binsize_;
}
inline void CongestionProfile::set_binsize(::google::protobuf::uint32 value) {
  set_has_binsize();
  binsize_ = value;
}

// repeated double binprobs = 3;
inline int CongestionProfile::binprobs_size() const {
  return binprobs_.size();
}
inline void CongestionProfile::clear_binprobs() {
  binprobs_.Clear();
}
inline double CongestionProfile::binprobs(int index) const {
  return binprobs_.Get(index);
}
inline void CongestionProfile::set_binprobs(int index, double value) {
  binprobs_.Set(index, value);
}
inline void CongestionProfile::add_binprobs(double value) {
  binprobs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CongestionProfile::binprobs() const {
  return binprobs_;
}
inline ::google::protobuf::RepeatedField< double >*
CongestionProfile::mutable_binprobs() {
  return &binprobs_;
}

// -------------------------------------------------------------------

// NodeSpecification

// required string id = 1;
inline bool NodeSpecification::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeSpecification::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeSpecification::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeSpecification::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NodeSpecification::id() const {
  return *id_;
}
inline void NodeSpecification::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NodeSpecification::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NodeSpecification::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeSpecification::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* NodeSpecification::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeSpecification::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 congestion_profile = 2;
inline bool NodeSpecification::has_congestion_profile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeSpecification::set_has_congestion_profile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeSpecification::clear_has_congestion_profile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeSpecification::clear_congestion_profile() {
  congestion_profile_ = 0u;
  clear_has_congestion_profile();
}
inline ::google::protobuf::uint32 NodeSpecification::congestion_profile() const {
  return congestion_profile_;
}
inline void NodeSpecification::set_congestion_profile(::google::protobuf::uint32 value) {
  set_has_congestion_profile();
  congestion_profile_ = value;
}

// -------------------------------------------------------------------

// LatencyInfo

// required uint32 n1_idx = 1;
inline bool LatencyInfo::has_n1_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatencyInfo::set_has_n1_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatencyInfo::clear_has_n1_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatencyInfo::clear_n1_idx() {
  n1_idx_ = 0u;
  clear_has_n1_idx();
}
inline ::google::protobuf::uint32 LatencyInfo::n1_idx() const {
  return n1_idx_;
}
inline void LatencyInfo::set_n1_idx(::google::protobuf::uint32 value) {
  set_has_n1_idx();
  n1_idx_ = value;
}

// required uint32 n2_idx = 2;
inline bool LatencyInfo::has_n2_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatencyInfo::set_has_n2_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatencyInfo::clear_has_n2_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatencyInfo::clear_n2_idx() {
  n2_idx_ = 0u;
  clear_has_n2_idx();
}
inline ::google::protobuf::uint32 LatencyInfo::n2_idx() const {
  return n2_idx_;
}
inline void LatencyInfo::set_n2_idx(::google::protobuf::uint32 value) {
  set_has_n2_idx();
  n2_idx_ = value;
}

// required double latency = 3;
inline bool LatencyInfo::has_latency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LatencyInfo::set_has_latency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LatencyInfo::clear_has_latency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LatencyInfo::clear_latency() {
  latency_ = 0;
  clear_has_latency();
}
inline double LatencyInfo::latency() const {
  return latency_;
}
inline void LatencyInfo::set_latency(double value) {
  set_has_latency();
  latency_ = value;
}

// -------------------------------------------------------------------

// CoordInit

// optional uint32 num_networks = 1 [default = 1];
inline bool CoordInit::has_num_networks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordInit::set_has_num_networks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordInit::clear_has_num_networks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordInit::clear_num_networks() {
  num_networks_ = 1u;
  clear_has_num_networks();
}
inline ::google::protobuf::uint32 CoordInit::num_networks() const {
  return num_networks_;
}
inline void CoordInit::set_num_networks(::google::protobuf::uint32 value) {
  set_has_num_networks();
  num_networks_ = value;
}

// required uint32 update_interval_seconds = 2;
inline bool CoordInit::has_update_interval_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoordInit::set_has_update_interval_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoordInit::clear_has_update_interval_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoordInit::clear_update_interval_seconds() {
  update_interval_seconds_ = 0u;
  clear_has_update_interval_seconds();
}
inline ::google::protobuf::uint32 CoordInit::update_interval_seconds() const {
  return update_interval_seconds_;
}
inline void CoordInit::set_update_interval_seconds(::google::protobuf::uint32 value) {
  set_has_update_interval_seconds();
  update_interval_seconds_ = value;
}

// optional uint32 ping_interval_seconds = 3 [default = 3];
inline bool CoordInit::has_ping_interval_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoordInit::set_has_ping_interval_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoordInit::clear_has_ping_interval_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoordInit::clear_ping_interval_seconds() {
  ping_interval_seconds_ = 3u;
  clear_has_ping_interval_seconds();
}
inline ::google::protobuf::uint32 CoordInit::ping_interval_seconds() const {
  return ping_interval_seconds_;
}
inline void CoordInit::set_ping_interval_seconds(::google::protobuf::uint32 value) {
  set_has_ping_interval_seconds();
  ping_interval_seconds_ = value;
}

// repeated .torps.ext.NodeSpecification node_data = 4;
inline int CoordInit::node_data_size() const {
  return node_data_.size();
}
inline void CoordInit::clear_node_data() {
  node_data_.Clear();
}
inline const ::torps::ext::NodeSpecification& CoordInit::node_data(int index) const {
  return node_data_.Get(index);
}
inline ::torps::ext::NodeSpecification* CoordInit::mutable_node_data(int index) {
  return node_data_.Mutable(index);
}
inline ::torps::ext::NodeSpecification* CoordInit::add_node_data() {
  return node_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >&
CoordInit::node_data() const {
  return node_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::NodeSpecification >*
CoordInit::mutable_node_data() {
  return &node_data_;
}

// repeated .torps.ext.LatencyInfo latency_map = 5;
inline int CoordInit::latency_map_size() const {
  return latency_map_.size();
}
inline void CoordInit::clear_latency_map() {
  latency_map_.Clear();
}
inline const ::torps::ext::LatencyInfo& CoordInit::latency_map(int index) const {
  return latency_map_.Get(index);
}
inline ::torps::ext::LatencyInfo* CoordInit::mutable_latency_map(int index) {
  return latency_map_.Mutable(index);
}
inline ::torps::ext::LatencyInfo* CoordInit::add_latency_map() {
  return latency_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >&
CoordInit::latency_map() const {
  return latency_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::LatencyInfo >*
CoordInit::mutable_latency_map() {
  return &latency_map_;
}

// repeated .torps.ext.CongestionProfile congestion_profiles = 6;
inline int CoordInit::congestion_profiles_size() const {
  return congestion_profiles_.size();
}
inline void CoordInit::clear_congestion_profiles() {
  congestion_profiles_.Clear();
}
inline const ::torps::ext::CongestionProfile& CoordInit::congestion_profiles(int index) const {
  return congestion_profiles_.Get(index);
}
inline ::torps::ext::CongestionProfile* CoordInit::mutable_congestion_profiles(int index) {
  return congestion_profiles_.Mutable(index);
}
inline ::torps::ext::CongestionProfile* CoordInit::add_congestion_profiles() {
  return congestion_profiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::CongestionProfile >&
CoordInit::congestion_profiles() const {
  return congestion_profiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::CongestionProfile >*
CoordInit::mutable_congestion_profiles() {
  return &congestion_profiles_;
}

// -------------------------------------------------------------------

// Coordinate

// required string node_id = 1;
inline bool Coordinate::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coordinate::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coordinate::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coordinate::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& Coordinate::node_id() const {
  return *node_id_;
}
inline void Coordinate::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Coordinate::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Coordinate::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Coordinate::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* Coordinate::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Coordinate::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 dim = 2;
inline bool Coordinate::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Coordinate::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Coordinate::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Coordinate::clear_dim() {
  dim_ = 0;
  clear_has_dim();
}
inline ::google::protobuf::int32 Coordinate::dim() const {
  return dim_;
}
inline void Coordinate::set_dim(::google::protobuf::int32 value) {
  set_has_dim();
  dim_ = value;
}

// required double error = 3;
inline bool Coordinate::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Coordinate::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Coordinate::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Coordinate::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline double Coordinate::error() const {
  return error_;
}
inline void Coordinate::set_error(double value) {
  set_has_error();
  error_ = value;
}

// repeated double vectors = 4;
inline int Coordinate::vectors_size() const {
  return vectors_.size();
}
inline void Coordinate::clear_vectors() {
  vectors_.Clear();
}
inline double Coordinate::vectors(int index) const {
  return vectors_.Get(index);
}
inline void Coordinate::set_vectors(int index, double value) {
  vectors_.Set(index, value);
}
inline void Coordinate::add_vectors(double value) {
  vectors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Coordinate::vectors() const {
  return vectors_;
}
inline ::google::protobuf::RepeatedField< double >*
Coordinate::mutable_vectors() {
  return &vectors_;
}

// -------------------------------------------------------------------

// CoordUpdate

// required uint32 network_id = 1;
inline bool CoordUpdate::has_network_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordUpdate::set_has_network_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordUpdate::clear_has_network_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordUpdate::clear_network_id() {
  network_id_ = 0u;
  clear_has_network_id();
}
inline ::google::protobuf::uint32 CoordUpdate::network_id() const {
  return network_id_;
}
inline void CoordUpdate::set_network_id(::google::protobuf::uint32 value) {
  set_has_network_id();
  network_id_ = value;
}

// repeated .torps.ext.Coordinate coords = 2;
inline int CoordUpdate::coords_size() const {
  return coords_.size();
}
inline void CoordUpdate::clear_coords() {
  coords_.Clear();
}
inline const ::torps::ext::Coordinate& CoordUpdate::coords(int index) const {
  return coords_.Get(index);
}
inline ::torps::ext::Coordinate* CoordUpdate::mutable_coords(int index) {
  return coords_.Mutable(index);
}
inline ::torps::ext::Coordinate* CoordUpdate::add_coords() {
  return coords_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >&
CoordUpdate::coords() const {
  return coords_;
}
inline ::google::protobuf::RepeatedPtrField< ::torps::ext::Coordinate >*
CoordUpdate::mutable_coords() {
  return &coords_;
}

// -------------------------------------------------------------------

// ControlMessage

// required .torps.ext.Type type = 1;
inline bool ControlMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::torps::ext::Type ControlMessage::type() const {
  return static_cast< ::torps::ext::Type >(type_);
}
inline void ControlMessage::set_type(::torps::ext::Type value) {
  assert(::torps::ext::Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .torps.ext.CoordInit init_data = 2;
inline bool ControlMessage::has_init_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlMessage::set_has_init_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlMessage::clear_has_init_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlMessage::clear_init_data() {
  if (init_data_ != NULL) init_data_->::torps::ext::CoordInit::Clear();
  clear_has_init_data();
}
inline const ::torps::ext::CoordInit& ControlMessage::init_data() const {
  return init_data_ != NULL ? *init_data_ : *default_instance_->init_data_;
}
inline ::torps::ext::CoordInit* ControlMessage::mutable_init_data() {
  set_has_init_data();
  if (init_data_ == NULL) init_data_ = new ::torps::ext::CoordInit;
  return init_data_;
}
inline ::torps::ext::CoordInit* ControlMessage::release_init_data() {
  clear_has_init_data();
  ::torps::ext::CoordInit* temp = init_data_;
  init_data_ = NULL;
  return temp;
}
inline void ControlMessage::set_allocated_init_data(::torps::ext::CoordInit* init_data) {
  delete init_data_;
  init_data_ = init_data;
  if (init_data) {
    set_has_init_data();
  } else {
    clear_has_init_data();
  }
}

// optional .torps.ext.CoordUpdate update_data = 3;
inline bool ControlMessage::has_update_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlMessage::set_has_update_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlMessage::clear_has_update_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlMessage::clear_update_data() {
  if (update_data_ != NULL) update_data_->::torps::ext::CoordUpdate::Clear();
  clear_has_update_data();
}
inline const ::torps::ext::CoordUpdate& ControlMessage::update_data() const {
  return update_data_ != NULL ? *update_data_ : *default_instance_->update_data_;
}
inline ::torps::ext::CoordUpdate* ControlMessage::mutable_update_data() {
  set_has_update_data();
  if (update_data_ == NULL) update_data_ = new ::torps::ext::CoordUpdate;
  return update_data_;
}
inline ::torps::ext::CoordUpdate* ControlMessage::release_update_data() {
  clear_has_update_data();
  ::torps::ext::CoordUpdate* temp = update_data_;
  update_data_ = NULL;
  return temp;
}
inline void ControlMessage::set_allocated_update_data(::torps::ext::CoordUpdate* update_data) {
  delete update_data_;
  update_data_ = update_data;
  if (update_data) {
    set_has_update_data();
  } else {
    clear_has_update_data();
  }
}

// optional uint32 get_network_id = 4;
inline bool ControlMessage::has_get_network_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControlMessage::set_has_get_network_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControlMessage::clear_has_get_network_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControlMessage::clear_get_network_id() {
  get_network_id_ = 0u;
  clear_has_get_network_id();
}
inline ::google::protobuf::uint32 ControlMessage::get_network_id() const {
  return get_network_id_;
}
inline void ControlMessage::set_get_network_id(::google::protobuf::uint32 value) {
  set_has_get_network_id();
  get_network_id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ext
}  // namespace torps

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::torps::ext::StatusMessage_Status>() {
  return ::torps::ext::StatusMessage_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::torps::ext::Type>() {
  return ::torps::ext::Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_5fspec_2eproto__INCLUDED
